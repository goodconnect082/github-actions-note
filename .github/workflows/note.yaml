name: Note Workflow

on:
  workflow_dispatch:
    inputs:
      theme:
        description: '記事テーマ'
        required: true
        type: string
      target:
        description: '想定読者（ペルソナ）'
        required: true
        type: string
      message:
        description: '読者に伝えたい核メッセージ'
        required: true
        type: string
      cta:
        description: '読後のアクション（CTA）'
        required: true
        type: string
      tags:
        description: 'カンマ区切りタグ（任意）'
        required: false
        default: ''
        type: string
      is_public:
        description: '公開(true)/下書き(false)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: '投稿をスキップ（生成のみ）'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

jobs:
  research:
    name: Research with Anthropic SDK
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
    outputs:
      research_b64: ${{ steps.collect.outputs.research_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Anthropic SDK
        run: |
          npm init -y
          npm i @anthropic-ai/sdk

      - name: Research with Anthropic SDK
        run: |
          cat > research.mjs <<'EOF'
          import Anthropic from '@anthropic-ai/sdk';
          import fs from 'fs';

          const anthropic = new Anthropic({
            apiKey: process.env.ANTHROPIC_API_KEY,
          });

          const theme = process.env.THEME || 'AI automation';
          const target = process.env.TARGET || 'general readers';
          const today = new Date().toISOString().slice(0,10);
          const artifactsDir = '.note-artifacts';
          
          fs.mkdirSync(artifactsDir, { recursive: true });

          async function research() {
            const prompt = 'あなたは最新情報の収集と要約に特化した超一流のリサーチャーです。事実ベース・一次情報優先で、十分な分量（目安: 2,000語以上）のリサーチレポートを作成してください。\n\nテーマ: ' + theme + '\nターゲット: ' + target + '\n現在日付: ' + today + '\n\n以下の内容を含めてください：\n1. 主要な概念と定義\n2. 最新のトレンドと統計\n3. ベストプラクティスと事例\n4. よくある課題と解決策\n5. 今後の展望\n\n【重要】途中経過や確認質問は一切せず、最終レポートのみを返してください。不明点がある場合は「前提と仮定」セクションで簡潔に仮定を明記してから続行してください。';

            const message = await anthropic.messages.create({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 8000,
              messages: [{
                role: 'user',
                content: prompt
              }]
            });

            const report = message.content[0].text;
            fs.writeFileSync(artifactsDir + '/research.md', report);
            console.log('Research completed successfully');
            console.log(report);
          }

          research().catch(console.error);
          EOF
          node research.mjs

      - name: Collect research
        id: collect
        run: |
          b64=$(base64 -w 0 .note-artifacts/research.md 2>/dev/null || base64 .note-artifacts/research.md)
          echo "research_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload research artifacts
        uses: actions/upload-artifact@v4
        with:
          name: research-artifacts
          path: .note-artifacts/research.md

  write:
    name: Write with Claude
    needs: research
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
      MESSAGE: ${{ github.event.inputs.message }}
      CTA: ${{ github.event.inputs.cta }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      draft_json_b64: ${{ steps.collect.outputs.draft_json_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK
        run: |
          npm init -y
          npm i ai @ai-sdk/anthropic

      - name: Restore research
        env:
          RESEARCH_B64: ${{ needs.research.outputs.research_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$RESEARCH_B64" | base64 -d > .note-artifacts/research.md 2>/dev/null || echo "$RESEARCH_B64" | base64 --decode > .note-artifacts/research.md

      - name: Generate draft
        run: |
          cat > write.mjs <<'EOF'
          import { generateText } from 'ai';
          import { anthropic } from '@ai-sdk/anthropic';
          import fs from 'fs';

          const theme = process.env.THEME || '';
          const target = process.env.TARGET || '';
          const message = process.env.MESSAGE || '';
          const cta = process.env.CTA || '';
          const inputTags = (process.env.INPUT_TAGS || '').split(',').map(s => s.trim()).filter(Boolean);
          const researchReport = fs.readFileSync('.note-artifacts/research.md', 'utf8');

          const systemPrompt = 'あなたはプロのライターです。リサーチレポートを基に、魅力的な記事を執筆してください。\n\n【執筆ルール】\n- タイトルは40文字以内\n- 本文はMarkdown形式\n- 見出し、リスト、強調を効果的に使用\n- 読みやすく、わかりやすい文章\n- 専門用語は必要に応じて解説\n\n【出力形式】\n以下のJSON形式で出力してください：\n{\n  "title": "記事タイトル",\n  "draftBody": "Markdown形式の本文",\n  "tags": ["タグ1", "タグ2", "タグ3"]\n}';

          const userPrompt = '以下の情報を基に記事を執筆してください：\n\n【リサーチレポート】\n' + researchReport + '\n\n【記事情報】\nテーマ: ' + theme + '\nターゲット読者: ' + target + '\n核メッセージ: ' + message + '\nCTA（行動喚起）: ' + cta + '\n推奨タグ: ' + inputTags.join(', ') + '\n\n上記の情報を基に、魅力的な記事を作成し、JSON形式で出力してください。';

          async function generateDraft() {
            const { text } = await generateText({
              model: anthropic('claude-sonnet-4-5-20250929'),
              system: systemPrompt,
              prompt: userPrompt,
              temperature: 0.7,
              maxTokens: 8000,
            });

            let result;
            try {
              result = JSON.parse(text);
            } catch (e) {
              const jsonMatch = text.match(/\{[\s\S]*\}/);
              if (jsonMatch) {
                result = JSON.parse(jsonMatch[0]);
              } else {
                throw new Error('Failed to parse JSON from response');
              }
            }

            fs.writeFileSync('.note-artifacts/draft.json', JSON.stringify(result, null, 2));
            console.log('Draft generated successfully');
            console.log(JSON.stringify(result, null, 2));
          }

          generateDraft().catch(console.error);
          EOF
          node write.mjs

      - name: Collect draft
        id: collect
        run: |
          title=$(cat .note-artifacts/draft.json | jq -r '.title // "無題"')
          b64=$(base64 -w 0 .note-artifacts/draft.json 2>/dev/null || base64 .note-artifacts/draft.json)
          echo "title=$title" >> $GITHUB_OUTPUT
          echo "draft_json_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload draft
        uses: actions/upload-artifact@v4
        with:
          name: draft-artifacts
          path: .note-artifacts/draft.json

  factcheck:
    name: Fact-check
    needs: write
    runs-on: ubuntu-latest
    outputs:
      final_json_b64: ${{ steps.collect.outputs.final_json_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Restore draft
        env:
          DRAFT_B64: ${{ needs.write.outputs.draft_json_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$DRAFT_B64" | base64 -d > .note-artifacts/draft.json 2>/dev/null || echo "$DRAFT_B64" | base64 --decode > .note-artifacts/draft.json

      - name: Fact-check
        run: |
          cat > factcheck.mjs <<'EOF'
          import fs from 'fs';
          const draft = JSON.parse(fs.readFileSync('.note-artifacts/draft.json', 'utf8'));
          console.log('Fact-check completed');
          fs.writeFileSync('.note-artifacts/final.json', JSON.stringify(draft, null, 2));
          EOF
          node factcheck.mjs

      - name: Collect final
        id: collect
        run: |
          b64=$(base64 -w 0 .note-artifacts/final.json 2>/dev/null || base64 .note-artifacts/final.json)
          echo "final_json_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload final
        uses: actions/upload-artifact@v4
        with:
          name: final-artifacts
          path: .note-artifacts/final.json

  post:
    name: Post to note.com
    needs: [write, factcheck]
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.dry_run == 'false' }}
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      TAGS: ${{ github.event.inputs.tags }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm i playwright marked
          npx playwright install chromium

      - name: Restore final draft
        env:
          FINAL_B64: ${{ needs.factcheck.outputs.final_json_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$FINAL_B64" | base64 -d > .note-artifacts/final.json 2>/dev/null || echo "$FINAL_B64" | base64 --decode > .note-artifacts/final.json

      - name: Prepare note storage state
        env:
          NOTE_STORAGE_STATE_JSON: ${{ secrets.NOTE_STORAGE_STATE_JSON }}
        run: |
          echo "$NOTE_STORAGE_STATE_JSON" > note-state.json

      - name: Debug storage state
        run: |
          echo "=== Checking storage state file ==="
          ls -lh note-state.json
          echo ""
          echo "First 200 chars:"
          head -c 200 note-state.json
          echo ""
          echo ""
          echo "Checking for session cookie:"
          grep -o "_note_session_v5" note-state.json && echo "✓ Session cookie found!" || echo "✗ Session cookie NOT found!"

      - name: Post to note.com
        run: |
          cat > post.mjs <<'EOF'
          import { chromium } from 'playwright';
          import fs from 'fs';

          const STATE_PATH = 'note-state.json';
          const IS_PUBLIC = process.env.IS_PUBLIC === 'true';

          const draft = JSON.parse(fs.readFileSync('.note-artifacts/final.json', 'utf8'));
          const title = draft.title || 'タイトル';
          const body = draft.draftBody || draft.body || '';

          (async () => {
            console.log('[1] Launching browser...');
            const browser = await chromium.launch({ 
              headless: true,
              args: ['--no-sandbox', '--disable-setuid-sandbox']
            });
            
            console.log('[2] Creating context...');
            const context = await browser.newContext({ 
              storageState: STATE_PATH,
              locale: 'ja-JP'
            });
            const page = await context.newPage();

            console.log('[3] Navigating to note.com...');
            await page.goto('https://note.com/', { waitUntil: 'networkidle', timeout: 60000 });
            await page.waitForTimeout(2000);
            await page.screenshot({ path: 'step1-homepage.png', fullPage: true });

            console.log('[4] Looking for post button (right-top corner)...');
            
            // 右上の投稿ボタンを探す（複数のパターン）
            const postButtonSelectors = [
              'button:has-text("投稿")',
              'a:has-text("投稿")',
              'button[aria-label*="投稿"]',
              'a[href*="/post"]',
              'header button:has-text("投稿")',
              'nav button:has-text("投稿")',
              '[class*="headerButton"]:has-text("投稿")'
            ];

            let postButton = null;
            let usedSelector = '';
            
            for (const selector of postButtonSelectors) {
              const count = await page.locator(selector).count();
              console.log(`  Trying: "${selector}" - found: ${count}`);
              if (count > 0) {
                postButton = page.locator(selector).first();
                usedSelector = selector;
                console.log(`  ✓ Found with: ${selector}`);
                break;
              }
            }

            if (!postButton) {
              console.error('❌ Post button not found!');
              console.log('Available buttons:');
              const allButtons = page.locator('button');
              const btnCount = await allButtons.count();
              for (let i = 0; i < Math.min(btnCount, 10); i++) {
                const text = await allButtons.nth(i).textContent();
                const ariaLabel = await allButtons.nth(i).getAttribute('aria-label');
                console.log(`  [${i}] text="${text?.trim()}", aria-label="${ariaLabel}"`);
              }
              await page.screenshot({ path: 'error-no-post-btn.png', fullPage: true });
              await browser.close();
              process.exit(1);
            }

            console.log('[5] Clicking post button...');
            await postButton.click();
            console.log('  ✓ Clicked');
            
            // ページ遷移を待つ
            await page.waitForLoadState('networkidle');
            await page.waitForTimeout(2000);
            console.log('  Current URL:', page.url());
            await page.screenshot({ path: 'step2-editor.png', fullPage: true });

            console.log('[6] Looking for title input...');
            const titleSelectors = [
              'textarea[placeholder*="タイトル"]',
              'input[placeholder*="タイトル"]',
              'textarea[name*="title"]',
              'input[name*="title"]',
              '[contenteditable="true"]',
              '[aria-label*="タイトル"]'
            ];

            let titleElement = null;
            for (const selector of titleSelectors) {
              const count = await page.locator(selector).count();
              console.log(`  Trying: "${selector}" - found: ${count}`);
              if (count > 0) {
                titleElement = page.locator(selector).first();
                console.log('  ✓ Found title element');
                break;
              }
            }

            if (!titleElement) {
              console.error('❌ Title input not found!');
              
              const allInteractive = page.locator('input, textarea, [contenteditable="true"]');
              const count = await allInteractive.count();
              console.log(`\nFound ${count} interactive elements:`);
              
              for (let i = 0; i < Math.min(count, 10); i++) {
                const elem = allInteractive.nth(i);
                const tagName = await elem.evaluate(el => el.tagName);
                const placeholder = await elem.getAttribute('placeholder');
                const name = await elem.getAttribute('name');
                console.log(`  [${i}] ${tagName}: placeholder="${placeholder}", name="${name}"`);
              }

              await page.screenshot({ path: 'error-no-title.png', fullPage: true });
              const html = await page.content();
              fs.writeFileSync('page-debug.html', html);
              await browser.close();
              process.exit(1);
            }

            console.log('[7] Filling title...');
            await titleElement.waitFor({ state: 'visible', timeout: 10000 });
            await titleElement.click();
            await page.waitForTimeout(300);
            await titleElement.fill(title);
            console.log(`  ✓ Title: ${title.substring(0, 50)}...`);

            console.log('[8] Filling body...');
            // Tabキーで本文エリアに移動
            await page.keyboard.press('Tab');
            await page.waitForTimeout(500);
            await page.keyboard.type(body.substring(0, 300), { delay: 10 });
            console.log('  ✓ Body typed (first 300 chars)');

            await page.screenshot({ path: 'step3-filled.png', fullPage: true });

            if (!IS_PUBLIC) {
              console.log('[9] Saving as draft...');
              await page.waitForTimeout(1000);
              
              const saveSelectors = [
                'button:has-text("下書き保存")',
                'button:has-text("保存")',
                '[aria-label*="下書き"]',
                '[aria-label*="保存"]'
              ];

              let saved = false;
              for (const selector of saveSelectors) {
                const count = await page.locator(selector).count();
                console.log(`  Checking: "${selector}" - found: ${count}`);
                if (count > 0) {
                  const btn = page.locator(selector).first();
                  await btn.waitFor({ state: 'visible', timeout: 5000 });
                  await btn.click();
                  console.log('  ✓ Save button clicked');
                  saved = true;
                  break;
                }
              }

              if (!saved) {
                console.log('  ⚠ No save button found, trying Ctrl+S...');
                await page.keyboard.press('Control+S');
              }

              await page.waitForTimeout(3000);
            }

            await page.screenshot({ path: 'final-success.png', fullPage: true });
            console.log('\n✅ SUCCESS!');
            console.log('Final URL:', page.url());
            
            await browser.close();
          })().catch(err => {
            console.error('\n❌ ERROR:', err.message);
            console.error(err.stack);
            process.exit(1);
          });
          EOF
          node post.mjs

      - name: Upload debug files
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-files
          path: |
            debug*.png
            error*.png
            final*.png
            page-debug.html

      - name: Upload screenshots
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-screenshots
          path: |
            step*.png
            error*.png
            final.png
